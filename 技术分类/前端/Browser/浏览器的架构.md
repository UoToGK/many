# 浏览器地址栏输入一个 url 到底发生了什么

## 先梳理个主干，再来详细讲解

<font face="微软雅黑"  color=#0099ff size=3>

1. 从浏览器接收 url 到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）

2. 开启网络线程到发出一个完整的 http 请求（这一部分涉及到 dns 查询，tcp/ip 请求，五层因特网协议栈等知识）

3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）

4. 后台和前台的 http 交互（这一部分包括 http 头部、响应码、报文结构、cookie 等知识，可以提下静态资源的 cookie 优化，以及编码解码，如 gzip 压缩等）

5. 单独拎出来的缓存问题，http 的缓存（这部分包括 http 缓存头部，etag，catch-control 等）

6. 浏览器接收到 http 数据包后的解析流程（解析 html-词法分析然后解析成 dom 树、解析 css 生成 css 规则树、合并成 render 树，然后 layout、painting 渲染、复合图层的合成、GPU 绘制、外链资源的处理、loaded 和 domcontentloaded 等）

7. CSS 的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC 等概念）

8. JS 引擎解析过程（JS 的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）

9. 其它（可以拓展不同的知识模块，如跨域，web 安全，hybrid 模式等等内容）

#### 1. [从浏览器接收 url 到开启网络请求线程](https://segmentfault.com/a/1190000012925872)

<font color="#20B2AA">

- 区分进程和线程

  1. A 浏览器是多进程的

    <font color="#20B2AA">

  一个进程可能有个多个线程,其次你要明白的是系统是以进程为单位给应用程序分配资源(内存和 CPU 等)

- 进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- 线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
- 浏览器是多进程的
- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）
- 简单点理解，每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程。
  </font>

  2. B 浏览器都包含哪些进程？

     1. Browser 进程：浏览器的主进程（负责协调、主控），只有一个。作用有
        - 负责浏览器界面显示，与用户交互。如前进，后退等
        - 负责各个页面的管理，创建和销毁其他进程
        - 将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上
        - 网络资源的管理，下载等
     2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
     3. GPU 进程：最多一个，用于 3D 绘制等
     4. 浏览器渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）：默认每个 Tab 页面一个进程，互不 影响。主要作用为

        - 页面渲染，脚本执行，事件处理等,<即 GUI 渲染线程，JS 引擎线程，事件触发线程,定时触发器线程,异步 http 请求线程>

  3. C 浏览器多进程的优势  
     相比于单进程浏览器，多进程有如下优点：

  - 避免单个 page crash 影响整个浏览器
  - 避免第三方插件 crash 影响整个浏览器
  - 多进程充分利用多核优势
  - 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性
    <tr>
        简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势
    </tr>

  4. D 重点是浏览器内核（渲染进程）

  - GUI 渲染线程

    - 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
    - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
    - 注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

  - JS 引擎线程

    - 也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）
    - JS 引擎线程负责解析 Javascript 脚本，运行代码。
    - JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序
    - 同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

  - 事件触发线程

    - 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）
    - 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中
    - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
      注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）

  - 定时触发器线程

    - 传说中的 setInterval 与 setTimeout 所在线程

    * 浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线 程状态就会影响记计时的准确）
    * 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
    * 注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。

  - 异步 http 请求线程

    - 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
    - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

  5. F Browser 进程和浏览器内核（Renderer 进程）的通信过程

- 梳理浏览器内核中线程之间的关系
  - Browser 进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过 RendererHost 接口传递给 Render 进程
- Renderer 进程的 Renderer 接口收到消息，简单解释后，交给渲染线程，然后开始渲染

  - 渲染线程接收请求，加载网页并渲染网页，这其中可能需要 Browser 进程获取资源和需要 GPU 进程来帮助渲染
  - 当然可能会有 JS 线程操作 DOM（这样可能会造成回流并重绘）
  - 最后 Render 进程将结果传递给 Browser 进程

- Browser 进程接收到结果并将结果绘制出来

1. GUI 渲染线程与 JS 引擎线程互斥

   由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JS 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

   因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JS 引擎为互斥的关系，当 JS 引擎执行时 GUI 线程会被挂起，
   GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行。

2. JS 阻塞页面加载
   从上述的互斥关系，可以推导出，JS 如果执行时间过长就会阻塞页面。

   譬如，假设 JS 引擎正在进行巨量的计算，此时就算 GUI 有更新，也会被保存到队列中，等待 JS 引擎空闲后执行。
   然后，由于巨量计算，所以 JS 引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。

   所以，要尽量避免 JS 执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉

3. WebWorker，JS 的多线程？

4. WebWorker 与 SharedWorker

- 简单梳理下浏览器渲染流程

  1. load 事件与 DOMContentLoaded 事件的先后
  2. css 加载是否会阻塞 dom 树渲染？
  3. 普通图层和复合图层

- 从 Event Loop 谈 JS 的运行机制

  1. 事件循环机制进一步补充
  2. 单独说说定时器
  3. setTimeout 而不是 setInterval
  4. 事件循环进阶：macrotask 与 microtask

### [开启网络线程到发出一个完整的 http 请求](https://blog.csdn.net/sh435367384/article/details/79652159)

浏览器对同一域名下并发的 tcp 连接是有限制的,谷歌一般是 6 个，一般是（2-10）
</font>

</font>
