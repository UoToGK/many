/** \*\*\*\***\*\***\*\*\*\***\***\*\*\*\***\*\***\*\*\*\***关于正则的一些基本知识**\*\***\*\*\*\***\*\***\***\*\***\*\*\*\***\*\*** \*/

- \d 就是[0-9]。表示是一位数字。记忆方式：其英文是 digit（数字）。

- \D 就是[^0-9]。表示除数字外的任意字符。

- \w 就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w 是 word 的简写，也称单词字符。

- \W 是[^0-9a-za-z_]。非单词字符。

- \s 是[ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s 是 space character 的首字母。

* \S 是[^ \t\v\n\r\f]。 非空白符。

* .就是[^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号...中的每个点，都可以理解成占位符，表示任何类似的东西。

* 如果要匹配任意字符怎么办？可以使用[\d\D]、[\w\W]、[\s\S]和[^]中任何的一个。
  <p>
  b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, kitty kitty。首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，然后是1个或几个空白符(\s+)，最后是前面匹配的那个单词(\1)。

你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\w+)(或者把尖括号换成'也行：(?'Word'\w+)),这样就把\w+的组名指定为 Word 了。要反向引用这个分组捕获的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：\b(?<Word>\w+)\b\s+\k<Word>\b。

#### 分组语法 捕获

- (exp) 匹配 exp,并捕获文本到自动命名的组里
- (?<name>exp) 匹配 exp,并捕获文本到名称为 name 的组里，也可以写成(?'name'exp)
- (?:exp) 匹配 exp,不捕获匹配的文本

#### 位置指定

- (?=exp) 匹配 exp 前面的位置
- (?<=exp) 匹配 exp 后面的位置
- (?!exp) 匹配后面跟的不是 exp 的位置
- (?<!exp) 匹配前面不是 exp 的位置

#### 注释

- (?#comment) 这种类型的组不对正则表达式的处理产生任何影响，只是为了提供让人阅读注释

#### 位置指定

接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们用于指定一个位置，就像\b,^,\$那样，因此它们也被称为零宽断言。最好还是拿例子来说明吧：

- (?=exp)也叫零宽先行断言，它匹配文本中的某些位置，这些位置的后面能匹配给定的后缀 exp。比如\b\w+(?=ing\b)，匹配以 ing 结尾的单词的前面部分(除了 ing 以外的部分)，如果在查找 I'm singing while you're dancing.时，它会匹配 sing 和 danc。

- (?<=exp)也叫零宽后行断言，它匹配文本中的某些位置，这些位置的前面能给定的前缀匹配 exp。比如(?<=\bre)\w+\b 会匹配以 re 开头的单词的后半部分(除了 re 以外的部分)，例如在查找 reading a book 时，它匹配 ading。

- 假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?<=\d)\d{3})\*\b。请仔细分析这个表达式，它可能不像你第一眼看出来的那么简单。

</p>

```js
var singleLineComment =
  "(/\\*([^*]|[\\\r\\\n]|(\\*+([^*/]|[\\\r\\\n])))*\\*+/)|(//.*)"; //匹配单行注释
var moreLineComment = "(/*([^*]|[\r\n]|(*+([^*/]|[\r\n])))**+/)|(//.*) "; //匹配多行注释
// (/*([^*]|[\r\n]|(*+([^*/]|[\r\n])))[wxy]{3,3}**+/)
```

```js
匹配一个/** ... */注释块儿的正则表达式

\/\*\*(\s|\n|.)*?\*\/

匹配一个//注释块儿的正则表达式

\/\/(.*)

匹配一个//注释块儿的正则表达式,匹配包含中文和其他字符

\/\/(.*)[a-zA-Z\u4e00-\u9fa5]+(.*)
```

```js
module.exports = /<!--([\s\S]*?)-->/g; //html 删除注释
let reg = /[\w\W].*(http[\s\S].*pdf)[\s\S]/; // 匹配任意字符串中url
```

#### 匹配空白行

^(\t)\*$\n

[正则技巧](https://bbs.binmt.cc/thread-7490-1-1.html)

https://regex101.com/ [一个有用的正则网址](https://regex101.com/)

```html
匹配包括换行符在内的任意字符，以下为正确的正则表达式匹配规则：

([\s\S]*)

同时，也可以用 “([\d\D]*)”、“([\w\W]*)” 来表示。

在文本文件里, 这个表达式可以匹配所有的英文

/[ -~]/

这个表达式可以匹配所有的非英文(比如中文)

/[^ -~]/

/是VI里用的. 你在editplus或程序里不需要/

一、小括号()、中括号[]、大括号的区别

最基本的意思：小括号就是括号内看成一个整体 ，中括号就是匹配括号内的其中一个，大括号就是匹配几次(但是括号里变加上其他字符就有不同意思)

(1)小括号()：匹配小括号内的字符串，可以是一个，也可以是多个，常跟“|”(或)符号搭配使用，是多选结构的

示例1：string name = "way2014";  regex：(way|zgw)  result：结果是可以匹配出way的，因为是多选结构，小括号是匹配字符串的

示例2：string text = "123456789";  regex：(0-9)　result：结果是什么都匹配不到的，它只匹配字符串"0-9"而不是匹配数字, [0-9]这个字符组才是匹配0-9的数字

(2)中括号[]：匹配字符组内的字符，比如咱们常用的[0-9a-zA-Z.*?!]等，在[]内的字符都是字符，不是元字符，比如“0-9”、“a-z”这中间的“-”就是连接符号，表示范围的元字符，如果写成[-!?*(]这样的话，就是普通字符

示例1： string text = "1234567890";  regex：[0-9]  result：结果是可以匹配出字符串text内的任意数字了，像上边的【或符号“|”在字符组内就是一个普通字符】

示例2：string text = "a|e|s|v";  regex：[a|e|s]  result：结果就是匹配字符a、e、|三个字符，这个跟(a|e|s)有区别的，区别就是(a|e|s)匹配的是a、e、s三个字符的随意一个，三个中的任意一个，这是的|是元字符

(3)大括号{}：匹配次数，匹配在它之前表达式匹配出来的元素出现的次数，{n}出现n次、{n,}匹配最少出现n次、{n,m}匹配最少出现n次，最多出现m次

举例详细介绍 例如：

{n}

n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。

{n,}

n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。

{n,m}

m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。

?

当该字符紧跟在任何一个其他限制符(*,+,?，{n}，{n,}，{n,m})后面时，匹配模式是非贪婪的。非贪婪模式尽

可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。

在正则匹配中，一般将匹配的字符串称为分组 0，按括号出现的顺序依次将其内容称为分组 1、分组 2……例如正则 /(a)(b)/ 匹配字符串 "ab"，则分组 0 为 "ab"，分组 1 为 "a"，分组 2 为 "b"。执行正则匹配 /(a)(b)/.exec("ab") 的结果 ["ab", "a", "b"] 就是各个分组构成的字符串。如果去掉圆括号就没有分组 1、分组2……结果就是只包含分组 0 即匹配字符串的长度为 1 的数组 ["ab"]。

这里顺便说一下贪婪和非贪婪的匹配原理(注：JAVA默认是贪婪模式)：

a)如果是贪婪匹配模式则匹配结果为最长匹配，正则表达式引擎会一直匹配到字符串最后，当匹配为false时，通过回溯的方式，倒退找到倒数第一个匹配位置，返回匹配结果

b)如果是非贪婪匹配模式则匹配结果为最短匹配，正则表达式引擎会匹配到符合pattern的末尾位置那个字符，然后再往后走一步，发现匹配为false， 又回溯到找到回退的最近一个匹配为true的位置，返回结果。

可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。还有一个特殊的组matcher.group(0)，它总是代表整个表达式。该组不包括在 groupCount 的返回值中。
```


```python
import re

zstring = """
1.更高转化率：更多数据反馈，转化成本1.达到CPC未达到的新低。

2.覆盖人群更精准：计划稳定后，无需限制人群，通过模型触达更容易产生转化的人群。

3.流量更优质：转化率自动提升，ECPM竞争力更强，更容易获得优质流量。

4.更易操作：只需提供优质创意&落地页，其他交给系统自动优化。


5.更持久转化效果：单条计划投放时长更长，转化成本依然在接受值范围内。
"""
# [\s\S]* 匹配任意字符包括任意空行
res = re.findall(r"1\.(.*)[\s\S]*2\.(.*)[\s\S]*3\.(.*)[\s\S]*4\.(.*)[\s\S]*5\.(.*)", zstring)
print(res)
```